#ifndef HW_H
#define HW_H

#include "mt_xgpio.h"
#include "xparameters.h"
#include <string>

using namespace std;

XGpio res;
MtXGpio leds(XPAR_AXI_GPIO_LEDS_DEVICE_ID, ~0xF, ~0x3F);
MtXGpio ctrl(XPAR_AXI_GPIO_CONTROL_DEVICE_ID);
MtXGpio poly(XPAR_AXI_GPIO_POLYNOMIAL_DEVICE_ID);

void delayMs(int ms) {
	int dv = ms * 100000;
	for (int i = 0; i < dv; ++i);
}
void delayUs(int us) {
	int dv = us * 100000000;
	for (int i = 0; i < dv; ++i);
}

class TRNG {
protected:
	MtXgpioBit* Enable_;
	MtXgpioBit* Reset_;
	MtXgpioBit* Ready_;
	u32 cmax_ = 0;
public:
	TRNG() {
		Enable_ = new MtXgpioBit(0, 1, ctrl);
		Reset_ = new MtXgpioBit(1, 1, ctrl);
		Ready_ = new MtXgpioBit(0, 1, ctrl);

	}
	void start() {
		Enable_->reset();
		Reset_->reset();
//		delayUs(1);
		Reset_->set();
//		delayUs(1);
		Reset_->reset();
		Enable_->set();
	}
	bool finished() {
		return Ready_->get();
	}
	void setCounterMax(u32 value) {
		ctrl.setValue(value, 2);
		cmax_ = value;
	}
	u32 getCounterMax() {
		return cmax_;
	}
	void setPoly(string poly) {
		u32 table[8];
		for (int i = 0; i < 8; ++i) {
			table[i] = 0x0;
		}
		int poly_len = poly.length();
		int index = 0;
		for (int i = poly_len-1; i >= 0; --i) {
			char c = poly[i];
			int bindex = index % 32;
			int windex = index / 32;
			if (c == '1') {
				u32 mask = (0x1 << bindex);
				table[windex] |= mask;
			}
			++index;
		}
		for (int i = 0; i < 8; ++i) {
			u32 ch2 = i;
			poly.
		}
	}
};






string getResult() {
	XGpio_Initialize(&res, XPAR_AXI_GPIO_RESULT_DEVICE_ID);
	string result = "";
	for (int i = 7; i >= 0; --i) {
		XGpio_DiscreteWrite(&res, 2, i);
		int r = XGpio_DiscreteRead(&res, 1);
		for (int p = 0; p < 32; ++p) {
			if ((0x80000000 & r) == 0) {
				result += "0";
			} else {
				result += "1";
			}
			r <<= 1;
		}
	}
	return result;
}


TRNG trng;

#endif
